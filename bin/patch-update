#!/bin/bash 

# patch-update - A quick version of refreshing a patch for a specific ebuild, use me with care. Intentionally dumb.
# $1 should be the full filename!
echo_red() {
	echo -e "\033[1;31m$*\033[0m"
}

echo_green() {
	echo -e "\033[1;32m$*\033[0m"
}

echo_yellow() {
	echo -e "\033[1;33m$*\033[0m"
}

# bin/auto-sync-cfg should be in .gitignore.
# No, that's invalid. Use the user's home directory (or root if you are crazy.).
if [[ -f ~/auto-sync-cfg ]]; then
	echo_green "Passed auto-sync-cfg sanity check."
	source ~/auto-sync-cfg
else
	echo_red "Failed auto-sync-cfg sanity check, copying template to user home directory."
	cp -v bin/auto-sync-cfg.skel ~/auto-sync-cfg
	exit 1	
fi

echo Updating $1 ...
cp -v $SOURCE_DIR/$1 ./$1
patch -p1 < $PATCH_DIR/$1.patch
# Why not just plain -u you might ask here, well, this reduces the chances of patch fails when ebuilds are updated.
diff -U 1 $SOURCE_DIR/$1 ./$1 > $PATCH_DIR/$1.patch
echo "Generated new diff for $1"
echo "Remember that generated patch does not include make_multilib changes"
